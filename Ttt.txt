// Global variables
let currentFile = null;
let currentImageData = null;

// DOM Elements
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const contentArea = document.getElementById('contentArea');
const previewImage = document.getElementById('previewImage');
const fileName = document.getElementById('fileName');
const fileSize = document.getElementById('fileSize');
const dimensions = document.getElementById('dimensions');
const metadataContainer = document.getElementById('metadataContainer');
const cameraInfo = document.getElementById('cameraInfo');
const gpsInfo = document.getElementById('gpsInfo');
const gpsCard = document.getElementById('gpsCard');
const dateInfo = document.getElementById('dateInfo');
const additionalInfo = document.getElementById('additionalInfo');
const downloadOriginal = document.getElementById('downloadOriginal');
const newImage = document.getElementById('newImage');
const removeMetadata = document.getElementById('removeMetadata');
const aboutLink = document.getElementById('aboutLink');
const aboutModal = document.getElementById('aboutModal');
const modalClose = document.querySelector('.modal-close');

// Event Listeners
uploadArea.addEventListener('click', () => fileInput.click());
uploadArea.addEventListener('dragover', handleDragOver);
uploadArea.addEventListener('dragleave', handleDragLeave);
uploadArea.addEventListener('drop', handleDrop);
fileInput.addEventListener('change', handleFileSelect);
downloadOriginal.addEventListener('click', downloadOriginalImage);
newImage.addEventListener('click', resetApp);
removeMetadata.addEventListener('click', removeMetadataAndDownload);
aboutLink.addEventListener('click', (e) => {
    e.preventDefault();
    aboutModal.classList.remove('hidden');
});
modalClose.addEventListener('click', () => {
    aboutModal.classList.add('hidden');
});
window.addEventListener('click', (e) => {
    if (e.target === aboutModal) {
        aboutModal.classList.add('hidden');
    }
});

// Drag and Drop Handlers
function handleDragOver(e) {
    e.preventDefault();
    uploadArea.classList.add('dragover');
}

function handleDragLeave(e) {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
}

function handleDrop(e) {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
}

function handleFileSelect(e) {
    const files = e.target.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
}

// Main File Handler
function handleFile(file) {
    if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file.');
        return;
    }

    currentFile = file;
    
    // Show file info
    fileName.textContent = file.name;
    fileSize.textContent = formatFileSize(file.size);
    
    // Read and display image
    const reader = new FileReader();
    reader.onload = function(e) {
        currentImageData = e.target.result;
        previewImage.src = currentImageData;
        
        // Get image dimensions
        previewImage.onload = function() {
            dimensions.textContent = `${this.naturalWidth} √ó ${this.naturalHeight} px`;
        };
        
        // Extract EXIF data
        extractMetadata(previewImage);
    };
    reader.readAsDataURL(file);
    
    // Show content area
    contentArea.classList.remove('hidden');
}

// Extract and Display Metadata
function extractMetadata(img) {
    EXIF.getData(img, function() {
        const allMetadata = EXIF.getAllTags(this);
        
        if (Object.keys(allMetadata).length === 0) {
            metadataContainer.innerHTML = '<div class="no-data">No EXIF metadata found in this image.</div>';
            cameraInfo.innerHTML = '<div class="no-data">No camera information available.</div>';
            dateInfo.innerHTML = '<div class="no-data">No date information available.</div>';
            additionalInfo.innerHTML = '<div class="no-data">No additional metadata available.</div>';
            return;
        }
        
        // Display all metadata in raw format
        displayAllMetadata(allMetadata);
        
        // Display organized camera info
        displayCameraInfo(allMetadata);
        
        // Display GPS info
        displayGPSInfo(allMetadata);
        
        // Display date info
        displayDateInfo(allMetadata);
        
        // Display additional metadata
        displayAdditionalMetadata(allMetadata);
    });
}

function displayAllMetadata(metadata) {
    let html = '<div class="metadata-grid">';
    
    for (let tag in metadata) {
        if (metadata.hasOwnProperty(tag)) {
            let value = metadata[tag];
            
            // Format complex objects
            if (typeof value === 'object' && value !== null) {
                value = JSON.stringify(value);
            }
            
            html += `
                <div class="metadata-item">
                    <div class="metadata-label">${tag}</div>
                    <div class="metadata-value">${value}</div>
                </div>
            `;
        }
    }
    
    html += '</div>';
    metadataContainer.innerHTML = html;
}

function displayCameraInfo(metadata) {
    const cameraData = [
        { label: 'Camera Make', value: metadata.Make },
        { label: 'Camera Model', value: metadata.Model },
        { label: 'Lens Model', value: metadata.LensModel },
        { label: 'ISO Speed', value: metadata.ISOSpeedRatings },
        { label: 'Aperture', value: metadata.FNumber ? `f/${metadata.FNumber}` : metadata.ApertureValue },
        { label: 'Shutter Speed', value: metadata.ExposureTime ? `${metadata.ExposureTime}s` : null },
        { label: 'Focal Length', value: metadata.FocalLength ? `${metadata.FocalLength}mm` : null },
        { label: 'Exposure Program', value: getExposureProgram(metadata.ExposureProgram) },
        { label: 'Metering Mode', value: getMeteringMode(metadata.MeteringMode) },
        { label: 'Flash', value: metadata.Flash !== undefined ? (metadata.Flash & 1 ? 'Fired' : 'Did not fire') : null },
        { label: 'White Balance', value: metadata.WhiteBalance === 0 ? 'Auto' : metadata.WhiteBalance === 1 ? 'Manual' : null },
        { label: 'Exposure Bias', value: metadata.ExposureBiasValue ? `${metadata.ExposureBiasValue} EV` : null }
    ];
    
    let html = '';
    let hasData = false;
    
    cameraData.forEach(item => {
        if (item.value !== undefined && item.value !== null) {
            hasData = true;
            html += `
                <div class="info-box">
                    <div class="info-box-label">${item.label}</div>
                    <div class="info-box-value">${item.value}</div>
                </div>
            `;
        }
    });
    
    cameraInfo.innerHTML = hasData ? html : '<div class="no-data">No camera information available.</div>';
}

function displayGPSInfo(metadata) {
    const lat = metadata.GPSLatitude;
    const lon = metadata.GPSLongitude;
    const latRef = metadata.GPSLatitudeRef;
    const lonRef = metadata.GPSLongitudeRef;
    
    if (lat && lon && latRef && lonRef) {
        const latitude = convertDMSToDD(lat, latRef);
        const longitude = convertDMSToDD(lon, lonRef);
        
        const gpsData = [
            { label: 'Latitude', value: `${latitude.toFixed(6)}¬∞ ${latRef}` },
            { label: 'Longitude', value: `${longitude.toFixed(6)}¬∞ ${lonRef}` },
            { label: 'Altitude', value: metadata.GPSAltitude ? `${metadata.GPSAltitude}m` : 'N/A' },
            { label: 'GPS Timestamp', value: metadata.GPSDateStamp || 'N/A' }
        ];
        
        let html = '';
        gpsData.forEach(item => {
            html += `
                <div class="info-box">
                    <div class="info-box-label">${item.label}</div>
                    <div class="info-box-value">${item.value}</div>
                </div>
            `;
        });
        
        html += `
            <div class="map-container">
                <a href="https://www.google.com/maps?q=${latitude},${longitude}" 
                   target="_blank" 
                   class="map-link">
                    üó∫Ô∏è View on Google Maps
                </a>
            </div>
        `;
        
        gpsInfo.innerHTML = html;
        gpsCard.classList.remove('hidden');
    } else {
        gpsCard.classList.add('hidden');
    }
}

function displayDateInfo(metadata) {
    const dateData = [
        { label: 'Date Taken (Original)', value: metadata.DateTimeOriginal },
        { label: 'Date Modified', value: metadata.DateTime },
        { label: 'Date Digitized', value: metadata.DateTimeDigitized },
        { label: 'Timezone Offset', value: metadata.OffsetTime }
    ];
    
    let html = '';
    let hasData = false;
    
    dateData.forEach(item => {
        if (item.value) {
            hasData = true;
            html += `
                <div class="info-box">
                    <div class="info-box-label">${item.label}</div>
                    <div class="info-box-value">${item.value}</div>
                </div>
            `;
        }
    });
    
    dateInfo.innerHTML = hasData ? html : '<div class="no-data">No date information available.</div>';
}

function displayAdditionalMetadata(metadata) {
    const additionalData = [
        { label: 'Software', value: metadata.Software },
        { label: 'Artist/Author', value: metadata.Artist },
        { label: 'Copyright', value: metadata.Copyright },
        { label: 'Color Space', value: metadata.ColorSpace === 1 ? 'sRGB' : metadata.ColorSpace },
        { label: 'Orientation', value: getOrientation(metadata.Orientation) },
        { label: 'Resolution Unit', value: metadata.ResolutionUnit === 2 ? 'inches' : metadata.ResolutionUnit === 3 ? 'cm' : null },
        { label: 'X Resolution', value: metadata.XResolution },
        { label: 'Y Resolution', value: metadata.YResolution },
        { label: 'Image Description', value: metadata.ImageDescription },
        { label: 'User Comment', value: metadata.UserComment },
        { label: 'Scene Type', value: metadata.SceneType }
    ];
    
    let html = '<div class="metadata-grid">';
    let hasData = false;
    
    additionalData.forEach(item => {
        if (item.value !== undefined && item.value !== null) {
            hasData = true;
            html += `
                <div class="metadata-item">
                    <div class="metadata-label">${item.label}</div>
                    <div class="metadata-value">${item.value}</div>
                </div>
            `;
        }
    });
    
    html += '</div>';
    additionalInfo.innerHTML = hasData ? html : '<div class="no-data">No additional metadata available.</div>';
}

// Helper Functions
function convertDMSToDD(dms, ref) {
    const degrees = dms[0];
    const minutes = dms[1];
    const seconds = dms[2];
    
    let dd = degrees + minutes / 60 + seconds / 3600;
    
    if (ref === 'S' || ref === 'W') {
        dd = dd * -1;
    }
    
    return dd;
}

function getExposureProgram(value) {
    const programs = {
        0: 'Not defined',
        1: 'Manual',
        2: 'Normal program',
        3: 'Aperture priority',
        4: 'Shutter priority',
        5: 'Creative program',
        6: 'Action program',
        7: 'Portrait mode',
        8: 'Landscape mode'
    };
    return programs[value] || null;
}

function getMeteringMode(value) {
    const modes = {
        0: 'Unknown',
        1: 'Average',
        2: 'Center-weighted average',
        3: 'Spot',
        4: 'Multi-spot',
        5: 'Pattern',
        6: 'Partial',
        255: 'Other'
    };
    return modes[value] || null;
}

function getOrientation(value) {
    const orientations = {
        1: 'Normal',
        2: 'Flipped horizontally',
        3: 'Rotated 180¬∞',
        4: 'Flipped vertically',
        5: 'Rotated 90¬∞ CCW and flipped vertically',
        6: 'Rotated 90¬∞ CW',
        7: 'Rotated 90¬∞ CW and flipped vertically',
        8: 'Rotated 90¬∞ CCW'
    };
    return orientations[value] || null;
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// Download Original Image
function downloadOriginalImage() {
    if (!currentFile) return;
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(currentFile);
    link.download = currentFile.name;
    link.click();
    URL.revokeObjectURL(link.href);
}

// Remove Metadata and Download
function removeMetadataAndDownload() {
    if (!previewImage.src) return;
    
    // Create a canvas to redraw the image without metadata
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = previewImage.naturalWidth;
    canvas.height = previewImage.naturalHeight;
    
    // Draw image on canvas (this strips EXIF data)
    ctx.drawImage(previewImage, 0, 0);
    
    // Convert canvas to blob
    canvas.toBlob(function(blob) {
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        // Create filename
        const originalName = currentFile.name;
        const nameWithoutExt = originalName.substring(0, originalName.lastIndexOf('.'));
        const ext = originalName.substring(originalName.lastIndexOf('.'));
        const newName = `${nameWithoutExt}_no_metadata${ext}`;
        
        link.href = url;
        link.download = newName;
        link.click();
        
        URL.revokeObjectURL(url);
    }, currentFile.type || 'image/jpeg', 0.95);
}

// Reset App
function resetApp() {
    currentFile = null;
    currentImageData = null;
    fileInput.value = '';
    contentArea.classList.add('hidden');
    previewImage.src = '';
    metadataContainer.innerHTML = '<div class="loading">Loading metadata...</div>';
}

// Service Worker for Offline Support
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
            .then(registration => console.log('SW registered'))
            .catch(err => console.log('SW registration failed'));
    });
}
